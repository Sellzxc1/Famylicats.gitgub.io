<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FAMYLICATS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #222;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #game-canvas {
            display: block;
            background-color: #87CEEB;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #day-night {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #health-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #ff0000;
            transition: width 0.3s;
        }
        #exp-bar {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 200px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
        }
        #exp-fill {
            height: 100%;
            width: 0%;
            background-color: #00ff00;
            transition: width 0.3s;
        }
        #level {
            position: absolute;
            top: 80px;
            left: 220px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #loading-progress {
            width: 80%;
            height: 20px;
            margin-top: 20px;
            background-color: #333;
        }
        #loading-progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        
        /* Warcraft-style UI */
        #avatar-container {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #483112;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #avatar {
            width: 80px;
            height: 80px;
            background-image: url('AVA.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        #action-buttons {
            position: absolute;
            bottom: 120px;
            left: 140px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-gap: 5px;
        }
        
        .action-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(50, 50, 50, 0.7);
            border: 2px solid #483112;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 12px;
            text-align: center;
            cursor: pointer;
        }
        
        #attack-btn {
            background-color: rgba(255, 0, 0, 0.3);
            border: 2px solid #800000;
        }
        
        #attack-btn.active {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #000;
        }
        
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 140px;
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-gap: 5px;
        }
        
        .inventory-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(50, 50, 50, 0.7);
            border: 2px solid #483112;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 12px;
            position: relative;
        }
        
        .inventory-slot.selected {
            border: 2px solid gold;
            background-color: rgba(100, 100, 0, 0.5);
        }
        
        .inventory-slot img {
            width: 40px;
            height: 40px;
        }
        
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        
        #build-mode-indicator {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 100px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 12px;
        }
        
        /* Crafting Window Styles */
        #crafting-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #483112;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #crafting-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        .crafting-recipe {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .recipe-inputs, .recipe-outputs {
            display: flex;
            align-items: center;
        }
        
        .recipe-arrow {
            margin: 0 15px;
            font-size: 20px;
            color: #ffa500;
        }
        
        .recipe-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .recipe-item img {
            width: 32px;
            height: 32px;
        }
        
        .recipe-item-count {
            font-size: 12px;
            margin-top: 2px;
        }
        
        .craft-btn {
            margin-left: auto;
            padding: 5px 10px;
            background-color: #ffa500;
            border: none;
            border-radius: 3px;
            color: black;
            cursor: pointer;
        }
        
        .craft-btn:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        #close-crafting {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* BLOCK4 Window Styles */
        #block4-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #block4-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        .block4-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .block4-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        
        .block4-slot img {
            width: 40px;
            height: 40px;
        }
        
        .block4-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        
        #close-block4 {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        .transfer-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        .transfer-btn {
            padding: 5px 10px;
            background-color: #ffa500;
            border: none;
            border-radius: 3px;
            color: black;
            cursor: pointer;
        }
        
        .transfer-btn:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        /* BLOCK5 Window Styles */
        #block5-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #block5-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        #close-block5 {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* BLOCK6 Window Styles */
        #block6-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #block6-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        #close-block6 {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* BLOCK8 Window Styles */
        #block8-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #block8-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        #close-block8 {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* BLOCK9 Window Styles */
        #block9-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 50;
        }
        
        #block9-window h2 {
            margin-top: 0;
            text-align: center;
            color: #ffa500;
        }
        
        #close-block9 {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Loading Game...</h1>
        <div id="loading-progress">
            <div id="loading-progress-bar"></div>
        </div>
    </div>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui">
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="exp-bar">
                <div id="exp-fill"></div>
            </div>
            <div id="level">Level: 1</div>
        </div>
        <div id="day-night">Day</div>
        <div id="build-mode-indicator">Build: OFF</div>
        
        <!-- Warcraft-style UI -->
        <div id="warcraft-ui">
            <div id="avatar-container">
                <div id="avatar"></div>
            </div>
            
            <div id="action-buttons">
                <div id="attack-btn" class="action-btn">ATTACK</div>
                <div id="craft-btn" class="action-btn">CRAFT</div>
                <div id="build-btn" class="action-btn">BUILD</div>
                <div id="mine-btn" class="action-btn">MINE</div>
            </div>
            
            <div id="inventory"></div>
        </div>
        
        <!-- Crafting Window -->
        <div id="crafting-window">
            <button id="close-crafting">×</button>
            <h2>Crafting</h2>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/tree.png" alt="Wood">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">4</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-blocks">Craft</button>
            </div>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/rock.png" alt="Stone">
                        <div class="recipe-item-count">4</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK2.png" alt="Stone Block">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-stone-blocks">Craft</button>
            </div>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">2</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK3.png" alt="Player Pass Block">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-player-pass-blocks">Craft</button>
            </div>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">9</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK4.png" alt="Storage Block">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-storage-blocks">Craft</button>
            </div>
            <!-- New crafting recipe for PAlKA from BLOCK1 -->
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/PAlKA.png" alt="PAlKA">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-palka">Craft</button>
            </div>
            <!-- New crafting recipe for BLOCK5 from 9 BLOCK2 -->
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK2.png" alt="Stone Block">
                        <div class="recipe-item-count">9</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK5.png" alt="BLOCK5">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-block5">Craft</button>
            </div>
            <!-- New crafting recipe for BLOCK6 from 1 UGL and 1 PAlKA -->
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/UGL.png" alt="UGL">
                        <div class="recipe-item-count">1</div>
                    </div>
                    <div class="recipe-item">
                        <img src="assets/PAlKA.png" alt="PAlKA">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK6.png" alt="BLOCK6">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-block6">Craft</button>
            </div>
            <!-- New crafting recipe for BLOCK8 from 3 BLOCK7 and 3 BLOCK1 -->
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK7.png" alt="BLOCK7">
                        <div class="recipe-item-count">3</div>
                    </div>
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">3</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK8.png" alt="BLOCK8">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-block8">Craft</button>
            </div>
            <!-- New crafting recipe for BLOCK9 from 4 BLOCK1 -->
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">4</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK9.png" alt="BLOCK9">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-block9">Craft</button>
            </div>
        </div>
        
        <!-- BLOCK4 Window -->
        <div id="block4-window">
            <button id="close-block4">×</button>
            <h2>Storage Block</h2>
            <div class="block4-slots">
                <div class="block4-slot" data-slot="0"></div>
                <div class="block4-slot" data-slot="1"></div>
                <div class="block4-slot" data-slot="2"></div>
                <div class="block4-slot" data-slot="3"></div>
                <div class="block4-slot" data-slot="4"></div>
                <div class="block4-slot" data-slot="5"></div>
            </div>
            <div class="transfer-controls">
                <button class="transfer-btn" id="transfer-one">Transfer 1</button>
                <button class="transfer-btn" id="transfer-half">Transfer Half</button>
                <button class="transfer-btn" id="transfer-all">Transfer All</button>
            </div>
        </div>
        
        <!-- BLOCK5 Window -->
        <div id="block5-window">
            <button id="close-block5">×</button>
            <h2>PECHKA</h2>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/BLOCK1.png" alt="Block">
                        <div class="recipe-item-count">2</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/UGL.png" alt="UGL">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-ugl">Craft</button>
            </div>
        </div>
        
        <!-- BLOCK6 Window -->
        <div id="block6-window">
            <button id="close-block6">×</button>
            <h2>Light Block</h2>
            <p>This block provides light during the night.</p>
        </div>
        
        <!-- BLOCK8 Window -->
        <div id="block8-window">
            <button id="close-block8">×</button>
            <h2>Time Block</h2>
            <p>Click to make it morning.</p>
        </div>
        
        <!-- BLOCK9 Window -->
        <div id="block9-window">
            <button id="close-block9">×</button>
            <h2>VERSTAK</h2>
            <div class="crafting-recipe">
                <div class="recipe-inputs">
                    <div class="recipe-item">
                        <img src="assets/PAlKA.png" alt="PAlKA">
                        <div class="recipe-item-count">2</div>
                    </div>
                </div>
                <div class="recipe-arrow">→</div>
                <div class="recipe-outputs">
                    <div class="recipe-item">
                        <img src="assets/CREST.png" alt="CREST">
                        <div class="recipe-item-count">1</div>
                    </div>
                </div>
                <button class="craft-btn" id="craft-crest">Craft</button>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const WORLD_SIZE = 5000;
        const TILE_SIZE = 64;
        const PLAYER_SIZE = 48;
        const SLIME_SIZE = 40;
        const OVCA_SIZE = 40;
        const GHOST_SIZE = 40;
        const TREE_SIZE = 80;
        const ROCK_SIZE = 50;
        const DAY_NIGHT_CYCLE = 600; // 10 minutes in seconds
        const NIGHT_DURATION = 480; // 8 minutes in seconds (as requested)
        const SLIME_SPAWN_RATE = 5; // seconds between spawns during night (reduced from 2)
        const SLIME_MAX_COUNT = 10; // Maximum number of slimes at once (new limit)
        const OVCA_SPAWN_RATE_FAST = 120; // 2 minutes in seconds
        const OVCA_SPAWN_RATE_SLOW = 1200; // 20 minutes in seconds
        const GHOST_SPAWN_RATE = 10; // seconds between spawns during night
        const GHOST_BASE_MAX = 6; // Base max ghosts at night
        const GHOST_MAX_LEVEL = 36; // Max ghosts at level 20+
        const BLOCK_SIZE = 32; // Size of building blocks
        const HARVEST_RANGE = 70; // Range for harvesting resources
        const LIGHT_RADIUS = 150; // Radius of light from BLOCK6
        const HEAD_DROP_CHANCE = 0.2; // 20% chance to drop HEAD.png from GHOST

        // Game variables
        let canvas, ctx;
        let player = {
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            speed: 3,
            health: 100,
            maxHealth: 100,
            exp: 0,
            level: 1,
            expToNextLevel: 100,
            attackCooldown: 0,
            attackRange: 70,
            attackDamage: 10,
            direction: { x: 0, y: 1 },
            inventory: {
                wood: 0,
                stone: 0,
                block1: 0,
                block2: 0,
                block3: 0,
                block4: 0,
                PAlKA: 0,
                BLOCK5: 0,
                UGL: 0,
                BLOCK6: 0,
                BLOCK7: 0,
                BLOCK8: 0,
                BLOCK9: 0,
                CREST: 0,
                HEAD: 0
            },
            selectedItem: null,
            buildMode: false,
            mineMode: false,
            ghostMode: false,
            ghostModeTimer: 0
        };
        let slimes = [];
        let ovcas = [];
        let ghosts = [];
        let trees = [];
        let rocks = [];
        let placedBlocks = []; // Array for player-built blocks
        let storageBlocks = {}; // Object to store BLOCK4 contents { "x,y": {items: [], counts: []} }
        let camera = { x: 0, y: 0 };
        let isDay = true;
        let dayNightTimer = 0;
        let slimeSpawnTimer = 0;
        let ovcaSpawnTimer = 0;
        let ghostSpawnTimer = 0;
        let attackPressed = false;
        let buildPressed = false;
        let craftPressed = false;
        let minePressed = false;
        let textures = {};
        let assetsLoaded = 0;
        const totalAssets = 18; // player, tree, rock, grass, slime, block1, block2, block3, block4, PAlKA, BLOCK5, UGL, BLOCK6, OVCA, BLOCK7, BLOCK8, BLOCK9, GHOST, CREST, HEAD

        // Initialize game
        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Try to load saved game
            loadGame();
            
            // Load textures
            loadTextures();
            
            // Initialize inventory UI
            initInventoryUI();
            
            // Initialize crafting UI
            initCraftingUI();
            
            // Initialize BLOCK4 UI
            initBlock4UI();
            
            // Initialize BLOCK5 UI
            initBlock5UI();
            
            // Initialize BLOCK6 UI
            initBlock6UI();
            
            // Initialize BLOCK8 UI
            initBlock8UI();
            
            // Initialize BLOCK9 UI
            initBlock9UI();
            
            // Initialize action buttons
            initActionButtons();
        }

        // Initialize action buttons
        function initActionButtons() {
            const attackBtn = document.getElementById('attack-btn');
            const craftBtn = document.getElementById('craft-btn');
            const buildBtn = document.getElementById('build-btn');
            const mineBtn = document.getElementById('mine-btn');
            
            attackBtn.addEventListener('click', () => {
                attackPressed = !attackPressed;
                attackBtn.classList.toggle('active');
                
                // If HEAD is selected and attack is pressed, activate ghost mode
                if (attackPressed && player.selectedItem === 'HEAD') {
                    activateGhostMode();
                }
            });
            
            craftBtn.addEventListener('click', () => {
                const craftingWindow = document.getElementById('crafting-window');
                craftingWindow.style.display = craftingWindow.style.display === 'block' ? 'none' : 'block';
                updateCraftingButtons();
            });
            
            buildBtn.addEventListener('click', () => {
                toggleBuildMode();
            });
            
            mineBtn.addEventListener('click', () => {
                toggleMineMode();
            });
        }

        // Load game state from localStorage
        function loadGame() {
            const savedGame = localStorage.getItem('mmoRpgGame');
            if (savedGame) {
                const gameState = JSON.parse(savedGame);
                
                // Restore player position and stats
                player.x = gameState.player.x || WORLD_SIZE / 2;
                player.y = gameState.player.y || WORLD_SIZE / 2;
                player.health = gameState.player.health || 100;
                player.maxHealth = gameState.player.maxHealth || 100;
                player.exp = gameState.player.exp || 0;
                player.level = gameState.player.level || 1;
                player.expToNextLevel = gameState.player.expToNextLevel || 100;
                player.inventory = gameState.player.inventory || { 
                    wood: 0, 
                    stone: 0, 
                    block1: 0, 
                    block2: 0, 
                    block3: 0, 
                    block4: 0,
                    PAlKA: 0,
                    BLOCK5: 0,
                    UGL: 0,
                    BLOCK6: 0,
                    BLOCK7: 0,
                    BLOCK8: 0,
                    BLOCK9: 0,
                    CREST: 0,
                    HEAD: 0
                };
                
                // Restore placed blocks
                placedBlocks = gameState.placedBlocks || [];
                
                // Restore storage blocks
                storageBlocks = gameState.storageBlocks || {};
                
                // Restore peaceful mobs (OVCA)
                ovcas = gameState.ovcas || [];
                
                // Restore day/night state
                isDay = gameState.isDay !== undefined ? gameState.isDay : true;
                dayNightTimer = gameState.dayNightTimer || 0;
                document.getElementById('day-night').textContent = isDay ? 'Day' : 'Night';
                
                // Update UI
                document.getElementById('health-fill').style.width = `${(player.health / player.maxHealth) * 100}%`;
                document.getElementById('exp-fill').style.width = `${(player.exp / player.expToNextLevel) * 100}%`;
                document.getElementById('level').textContent = `Level: ${player.level}`;
            }
        }

        // Save game state to localStorage
        function saveGame() {
            const gameState = {
                player: {
                    x: player.x,
                    y: player.y,
                    health: player.health,
                    maxHealth: player.maxHealth,
                    exp: player.exp,
                    level: player.level,
                    expToNextLevel: player.expToNextLevel,
                    inventory: player.inventory
                },
                placedBlocks: placedBlocks,
                storageBlocks: storageBlocks,
                ovcas: ovcas,
                isDay: isDay,
                dayNightTimer: dayNightTimer
            };
            localStorage.setItem('mmoRpgGame', JSON.stringify(gameState));
        }

        // Initialize inventory UI
        function initInventoryUI() {
            const inventory = document.getElementById('inventory');
            
            // Create inventory slots
            const items = [
                { id: 'wood', name: 'Wood', img: 'assets/tree.png' },
                { id: 'stone', name: 'Stone', img: 'assets/rock.png' },
                { id: 'block1', name: 'Block', img: 'assets/BLOCK1.png' },
                { id: 'block2', name: 'Stone Block', img: 'assets/BLOCK2.png' },
                { id: 'block3', name: 'Player Pass Block', img: 'assets/BLOCK3.png' },
                { id: 'block4', name: 'Storage Block', img: 'assets/BLOCK4.png' },
                { id: 'PAlKA', name: 'PAlKA', img: 'assets/PAlKA.png' },
                { id: 'BLOCK5', name: 'BLOCK5', img: 'assets/BLOCK5.png' },
                { id: 'UGL', name: 'UGL', img: 'assets/UGL.png' },
                { id: 'BLOCK6', name: 'BLOCK6', img: 'assets/BLOCK6.png' },
                { id: 'BLOCK7', name: 'BLOCK7', img: 'assets/BLOCK7.png' },
                { id: 'BLOCK8', name: 'BLOCK8', img: 'assets/BLOCK8.png' },
                { id: 'BLOCK9', name: 'BLOCK9', img: 'assets/BLOCK9.png' },
                { id: 'CREST', name: 'CREST', img: 'assets/CREST.png' },
                { id: 'HEAD', name: 'HEAD', img: 'assets/HEAD.png' }
            ];
            
            items.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.item = item.id;
                slot.innerHTML = `
                    <img src="${item.img}" alt="${item.name}">
                    <div class="item-count">0</div>
                `;
                
                slot.addEventListener('click', () => {
                    // Only allow selection if item count > 0
                    if (player.inventory[item.id] > 0) {
                        // Toggle selection
                        if (player.selectedItem === item.id) {
                            player.selectedItem = null;
                            document.querySelector('.inventory-slot.selected').classList.remove('selected');
                        } else {
                            if (player.selectedItem) {
                                document.querySelector('.inventory-slot.selected').classList.remove('selected');
                            }
                            player.selectedItem = item.id;
                            slot.classList.add('selected');
                        }
                    }
                });
                
                inventory.appendChild(slot);
            });
            
            // Update inventory counts initially
            updateInventoryUI();
        }

        // Activate ghost mode when HEAD is selected and attack is pressed
        function activateGhostMode() {
            if (player.inventory.HEAD > 0) {
                player.ghostMode = true;
                player.ghostModeTimer = 60; // 1 minute (60 seconds)
                player.inventory.HEAD--;
                updateInventoryUI();
                saveGame();
            }
        }

        // Update inventory UI
        function updateInventoryUI() {
            const slots = document.querySelectorAll('.inventory-slot');
            slots.forEach(slot => {
                const itemId = slot.dataset.item;
                const count = player.inventory[itemId] || 0;
                const countElement = slot.querySelector('.item-count');
                countElement.textContent = count;
                
                // Hide slot if count is 0
                if (count <= 0) {
                    slot.style.display = 'none';
                    
                    // Deselect if selected item is now 0
                    if (player.selectedItem === itemId) {
                        player.selectedItem = null;
                        slot.classList.remove('selected');
                    }
                } else {
                    slot.style.display = 'flex';
                }
            });
            
            // Also update crafting buttons when inventory changes
            updateCraftingButtons();
        }

        // Initialize crafting UI
        function initCraftingUI() {
            const craftingWindow = document.getElementById('crafting-window');
            const closeCrafting = document.getElementById('close-crafting');
            const craftBlocksBtn = document.getElementById('craft-blocks');
            const craftStoneBlocksBtn = document.getElementById('craft-stone-blocks');
            const craftPlayerPassBlocksBtn = document.getElementById('craft-player-pass-blocks');
            const craftStorageBlocksBtn = document.getElementById('craft-storage-blocks');
            const craftPalkaBtn = document.getElementById('craft-palka');
            const craftBlock5Btn = document.getElementById('craft-block5');
            const craftBlock6Btn = document.getElementById('craft-block6');
            const craftBlock8Btn = document.getElementById('craft-block8');
            const craftBlock9Btn = document.getElementById('craft-block9');
            
            // Close crafting window
            closeCrafting.addEventListener('click', () => {
                craftingWindow.style.display = 'none';
            });
            
            // Craft blocks button
            craftBlocksBtn.addEventListener('click', () => {
                if (player.inventory.wood >= 1) {
                    player.inventory.wood -= 1;
                    player.inventory.block1 += 4;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft stone blocks button
            craftStoneBlocksBtn.addEventListener('click', () => {
                if (player.inventory.stone >= 4) {
                    player.inventory.stone -= 4;
                    player.inventory.block2 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft player pass blocks button
            craftPlayerPassBlocksBtn.addEventListener('click', () => {
                if (player.inventory.block1 >= 2) {
                    player.inventory.block1 -= 2;
                    player.inventory.block3 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft storage blocks button
            craftStorageBlocksBtn.addEventListener('click', () => {
                if (player.inventory.block1 >= 9) {
                    player.inventory.block1 -= 9;
                    player.inventory.block4 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft PAlKA button
            craftPalkaBtn.addEventListener('click', () => {
                if (player.inventory.block1 >= 1) {
                    player.inventory.block1 -= 1;
                    player.inventory.PAlKA += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft BLOCK5 button
            craftBlock5Btn.addEventListener('click', () => {
                if (player.inventory.block2 >= 9) {
                    player.inventory.block2 -= 9;
                    player.inventory.BLOCK5 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft BLOCK6 button
            craftBlock6Btn.addEventListener('click', () => {
                if (player.inventory.UGL >= 1 && player.inventory.PAlKA >= 1) {
                    player.inventory.UGL -= 1;
                    player.inventory.PAlKA -= 1;
                    player.inventory.BLOCK6 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft BLOCK8 button
            craftBlock8Btn.addEventListener('click', () => {
                if (player.inventory.BLOCK7 >= 3 && player.inventory.block1 >= 3) {
                    player.inventory.BLOCK7 -= 3;
                    player.inventory.block1 -= 3;
                    player.inventory.BLOCK8 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
            
            // Craft BLOCK9 button
            craftBlock9Btn.addEventListener('click', () => {
                if (player.inventory.block1 >= 4) {
                    player.inventory.block1 -= 4;
                    player.inventory.BLOCK9 += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
        }

        // Initialize BLOCK4 UI
        function initBlock4UI() {
            const closeBlock4 = document.getElementById('close-block4');
            const block4Window = document.getElementById('block4-window');
            const transferOneBtn = document.getElementById('transfer-one');
            const transferHalfBtn = document.getElementById('transfer-half');
            const transferAllBtn = document.getElementById('transfer-all');
            
            // Close BLOCK4 window
            closeBlock4.addEventListener('click', () => {
                block4Window.style.display = 'none';
            });
            
            // Set up slot click handlers
            const slots = document.querySelectorAll('.block4-slot');
            slots.forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotIndex = parseInt(slot.dataset.slot);
                    const blockKey = block4Window.dataset.blockKey;
                    const storage = storageBlocks[blockKey];
                    
                    if (storage && storage.items[slotIndex]) {
                        // Take item from storage
                        const item = storage.items[slotIndex];
                        
                        // Add to player inventory
                        player.inventory[item] = (player.inventory[item] || 0) + storage.counts[slotIndex];
                        
                        // Remove from storage
                        storage.items[slotIndex] = null;
                        storage.counts[slotIndex] = 0;
                        
                        // Update UI
                        updateBlock4Window(blockKey);
                        updateInventoryUI();
                        saveGame();
                    }
                });
            });
            
            // Transfer buttons
            transferOneBtn.addEventListener('click', () => {
                transferItemsToBlock4(1);
            });
            
            transferHalfBtn.addEventListener('click', () => {
                if (player.selectedItem) {
                    const half = Math.floor(player.inventory[player.selectedItem] / 2);
                    if (half > 0) {
                        transferItemsToBlock4(half);
                    }
                }
            });
            
            transferAllBtn.addEventListener('click', () => {
                if (player.selectedItem) {
                    transferItemsToBlock4(player.inventory[player.selectedItem]);
                }
            });
        }
        
        // Initialize BLOCK5 UI
        function initBlock5UI() {
            const closeBlock5 = document.getElementById('close-block5');
            const block5Window = document.getElementById('block5-window');
            const craftUglBtn = document.getElementById('craft-ugl');
            
            // Close BLOCK5 window
            closeBlock5.addEventListener('click', () => {
                block5Window.style.display = 'none';
            });
            
            // Craft UGL button
            craftUglBtn.addEventListener('click', () => {
                if (player.inventory.block1 >= 2) {
                    player.inventory.block1 -= 2;
                    player.inventory.UGL += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
        }
        
        // Initialize BLOCK6 UI
        function initBlock6UI() {
            const closeBlock6 = document.getElementById('close-block6');
            const block6Window = document.getElementById('block6-window');
            
            // Close BLOCK6 window
            closeBlock6.addEventListener('click', () => {
                block6Window.style.display = 'none';
            });
        }
        
        // Initialize BLOCK8 UI
        function initBlock8UI() {
            const closeBlock8 = document.getElementById('close-block8');
            const block8Window = document.getElementById('block8-window');
            
            // Close BLOCK8 window
            closeBlock8.addEventListener('click', () => {
                block8Window.style.display = 'none';
            });
        }
        
        // Initialize BLOCK9 UI
        function initBlock9UI() {
            const closeBlock9 = document.getElementById('close-block9');
            const block9Window = document.getElementById('block9-window');
            const craftCrestBtn = document.getElementById('craft-crest');
            
            // Close BLOCK9 window
            closeBlock9.addEventListener('click', () => {
                block9Window.style.display = 'none';
            });
            
            // Craft CREST button
            craftCrestBtn.addEventListener('click', () => {
                if (player.inventory.PAlKA >= 2) {
                    player.inventory.PAlKA -= 2;
                    player.inventory.CREST += 1;
                    updateInventoryUI();
                    updateCraftingButtons();
                    saveGame();
                }
            });
        }

        // Transfer items to BLOCK4 storage
        function transferItemsToBlock4(amount) {
            if (!player.selectedItem || player.inventory[player.selectedItem] <= 0) return;
            
            const block4Window = document.getElementById('block4-window');
            const blockKey = block4Window.dataset.blockKey;
            const storage = storageBlocks[blockKey];
            
            // Find first available slot with same item or empty slot
            let targetSlot = -1;
            for (let i = 0; i < storage.items.length; i++) {
                if (storage.items[i] === player.selectedItem || storage.items[i] === null) {
                    targetSlot = i;
                    break;
                }
            }
            
            if (targetSlot === -1) return; // No available slots
            
            // Calculate actual amount to transfer (can't exceed inventory)
            const actualAmount = Math.min(amount, player.inventory[player.selectedItem]);
            
            // Update storage
            if (storage.items[targetSlot] === null) {
                storage.items[targetSlot] = player.selectedItem;
                storage.counts[targetSlot] = 0;
            }
            storage.counts[targetSlot] += actualAmount;
            
            // Update inventory
            player.inventory[player.selectedItem] -= actualAmount;
            
            // Update UIs
            updateBlock4Window(blockKey);
            updateInventoryUI();
            saveGame();
        }

        // Update BLOCK4 window with current contents
        function updateBlock4Window(blockKey) {
            const storage = storageBlocks[blockKey] || { items: Array(6).fill(null), counts: Array(6).fill(0) };
            const slots = document.querySelectorAll('.block4-slot');
            
            slots.forEach((slot, index) => {
                slot.innerHTML = ''; // Clear slot
                
                if (storage.items[index]) {
                    // Item exists in this slot
                    const item = storage.items[index];
                    const count = storage.counts[index];
                    
                    // Create image element
                    const img = document.createElement('img');
                    img.src = `assets/${item}.png`;
                    img.alt = item;
                    
                    // Create count element
                    const countElement = document.createElement('div');
                    countElement.className = 'item-count';
                    countElement.textContent = count;
                    
                    slot.appendChild(img);
                    slot.appendChild(countElement);
                }
            });
            
            // Update transfer buttons state
            updateTransferButtons();
        }

        // Update transfer buttons based on selected item
        function updateTransferButtons() {
            const transferOneBtn = document.getElementById('transfer-one');
            const transferHalfBtn = document.getElementById('transfer-half');
            const transferAllBtn = document.getElementById('transfer-all');
            
            const hasSelectedItem = player.selectedItem && player.inventory[player.selectedItem] > 0;
            
            transferOneBtn.disabled = !hasSelectedItem;
            transferHalfBtn.disabled = !hasSelectedItem || player.inventory[player.selectedItem] < 2;
            transferAllBtn.disabled = !hasSelectedItem;
        }

        // Update crafting buttons based on available resources
        function updateCraftingButtons() {
            const craftBlocksBtn = document.getElementById('craft-blocks');
            const craftStoneBlocksBtn = document.getElementById('craft-stone-blocks');
            const craftPlayerPassBlocksBtn = document.getElementById('craft-player-pass-blocks');
            const craftStorageBlocksBtn = document.getElementById('craft-storage-blocks');
            const craftPalkaBtn = document.getElementById('craft-palka');
            const craftBlock5Btn = document.getElementById('craft-block5');
            const craftBlock6Btn = document.getElementById('craft-block6');
            const craftBlock8Btn = document.getElementById('craft-block8');
            const craftBlock9Btn = document.getElementById('craft-block9');
            const craftUglBtn = document.getElementById('craft-ugl');
            const craftCrestBtn = document.getElementById('craft-crest');
            
            craftBlocksBtn.disabled = player.inventory.wood < 1;
            craftStoneBlocksBtn.disabled = player.inventory.stone < 4;
            craftPlayerPassBlocksBtn.disabled = player.inventory.block1 < 2;
            craftStorageBlocksBtn.disabled = player.inventory.block1 < 9;
            craftPalkaBtn.disabled = player.inventory.block1 < 1;
            craftBlock5Btn.disabled = player.inventory.block2 < 9;
            craftBlock6Btn.disabled = player.inventory.UGL < 1 || player.inventory.PAlKA < 1;
            craftBlock8Btn.disabled = player.inventory.BLOCK7 < 3 || player.inventory.block1 < 3;
            craftBlock9Btn.disabled = player.inventory.block1 < 4;
            if (craftUglBtn) craftUglBtn.disabled = player.inventory.block1 < 2;
            if (craftCrestBtn) craftCrestBtn.disabled = player.inventory.PAlKA < 2;
        }

        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Load textures
        function loadTextures() {
            textures.player = new Image();
            textures.player.onload = assetLoaded;
            textures.player.src = 'assets/player.png';
            
            textures.trava = new Image();
            textures.trava.onload = assetLoaded;
            textures.trava.src = 'assets/trava.png';
            
            textures.tree = new Image();
            textures.tree.onload = assetLoaded;
            textures.tree.src = 'assets/tree.png';
            
            textures.rock = new Image();
            textures.rock.onload = assetLoaded;
            textures.rock.src = 'assets/rock.png';
            
            textures.slime = new Image();
            textures.slime.onload = assetLoaded;
            textures.slime.src = 'assets/slime.png';
            
            textures.ovca = new Image();
            textures.ovca.onload = assetLoaded;
            textures.ovca.src = 'assets/OVCA.png';
            
            textures.ghost = new Image();
            textures.ghost.onload = assetLoaded;
            textures.ghost.src = 'assets/GHOST.png';
            
            textures.block1 = new Image();
            textures.block1.onload = assetLoaded;
            textures.block1.src = 'assets/BLOCK1.png';
            
            textures.block2 = new Image();
            textures.block2.onload = assetLoaded;
            textures.block2.src = 'assets/BLOCK2.png';
            
            textures.block3 = new Image();
            textures.block3.onload = assetLoaded;
            textures.block3.src = 'assets/BLOCK3.png';
            
            textures.block4 = new Image();
            textures.block4.onload = assetLoaded;
            textures.block4.src = 'assets/BLOCK4.png';
            
            // Load new textures
            textures.PAlKA = new Image();
            textures.PAlKA.onload = assetLoaded;
            textures.PAlKA.src = 'assets/PAlKA.png';
            
            textures.BLOCK5 = new Image();
            textures.BLOCK5.onload = assetLoaded;
            textures.BLOCK5.src = 'assets/BLOCK5.png';
            
            textures.UGL = new Image();
            textures.UGL.onload = assetLoaded;
            textures.UGL.src = 'assets/UGL.png';
            
            textures.BLOCK6 = new Image();
            textures.BLOCK6.onload = assetLoaded;
            textures.BLOCK6.src = 'assets/BLOCK6.png';
            
            textures.BLOCK7 = new Image();
            textures.BLOCK7.onload = assetLoaded;
            textures.BLOCK7.src = 'assets/BLOCK7.png';
            
            textures.BLOCK8 = new Image();
            textures.BLOCK8.onload = assetLoaded;
            textures.BLOCK8.src = 'assets/BLOCK8.png';
            
            textures.BLOCK9 = new Image();
            textures.BLOCK9.onload = assetLoaded;
            textures.BLOCK9.src = 'assets/BLOCK9.png';
            
            textures.CREST = new Image();
            textures.CREST.onload = assetLoaded;
            textures.CREST.src = 'assets/CREST.png';
            
            textures.HEAD = new Image();
            textures.HEAD.onload = assetLoaded;
            textures.HEAD.src = 'assets/HEAD.png';
        }

        function assetLoaded() {
            assetsLoaded++;
            const progress = (assetsLoaded / totalAssets) * 100;
            document.getElementById('loading-progress-bar').style.width = `${progress}%`;
            
            if (assetsLoaded === totalAssets) {
                // All assets loaded
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                    
                    // Generate world if not loaded from save
                    if (trees.length === 0 && rocks.length === 0) {
                        generateWorld();
                    }
                    
                    // Set up controls
                    setupControls();
                    
                    // Start game loop
                    requestAnimationFrame(gameLoop);
                }, 500);
            }
        }

        // Generate world with trees and rocks
        function generateWorld() {
            // Generate trees
            const treeCount = 200;
            for (let i = 0; i < treeCount; i++) {
                let validPosition = false;
                let x, y;
                
                while (!validPosition) {
                    x = Math.random() * (WORLD_SIZE - TREE_SIZE);
                    y = Math.random() * (WORLD_SIZE - TREE_SIZE);
                    validPosition = true;
                    
                    // Check distance to other trees
                    for (const tree of trees) {
                        const dx = tree.x - x;
                        const dy = tree.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                trees.push({ x, y, health: 3 }); // Trees now have health
            }
            
            // Generate rocks
            const rockCount = 300;
            for (let i = 0; i < rockCount; i++) {
                let validPosition = false;
                let x, y;
                
                while (!validPosition) {
                    x = Math.random() * (WORLD_SIZE - ROCK_SIZE);
                    y = Math.random() * (WORLD_SIZE - ROCK_SIZE);
                    validPosition = true;
                    
                    // Check distance to other rocks
                    for (const rock of rocks) {
                        const dx = rock.x - x;
                        const dy = rock.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 50) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check distance to trees
                    for (const tree of trees) {
                        const dx = tree.x - x;
                        const dy = tree.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 75) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                rocks.push({ x, y, health: 5 }); // Rocks now have health
            }
        }

        // Set up controls
        function setupControls() {
            // Attack button
            const attackBtn = document.getElementById('attack-btn');
            
            // Build button
            const buildBtn = document.getElementById('build-btn');
            
            // Mine button
            const mineBtn = document.getElementById('mine-btn');
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Click to place block in build mode
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchstart', handleCanvasClick);
        }

        // Toggle build mode
        function toggleBuildMode() {
            player.buildMode = !player.buildMode;
            player.mineMode = false; // Ensure mine mode is off
            const indicator = document.getElementById('build-mode-indicator');
            indicator.textContent = player.buildMode ? 'Build: ON' : 'Build: OFF';
            indicator.style.backgroundColor = player.buildMode ? 'rgba(0, 255, 0, 0.5)' : 'rgba(0, 0, 0, 0.5)';
        }

        // Toggle mine mode
        function toggleMineMode() {
            player.mineMode = !player.mineMode;
            player.buildMode = false; // Ensure build mode is off
            const indicator = document.getElementById('build-mode-indicator');
            indicator.textContent = player.mineMode ? 'Mine: ON' : 'Mine: OFF';
            indicator.style.backgroundColor = player.mineMode ? 'rgba(255, 165, 0, 0.5)' : 'rgba(0, 0, 0, 0.5)';
        }

        // Handle canvas click (for building and destroying blocks)
        function handleCanvasClick(e) {
            e.preventDefault();
            
            // Get click position in world coordinates
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const worldX = Math.floor((clientX + camera.x) / BLOCK_SIZE) * BLOCK_SIZE;
            const worldY = Math.floor((clientY + camera.y) / BLOCK_SIZE) * BLOCK_SIZE;
            const blockKey = `${worldX},${worldY}`;
            
            if (player.buildMode) {
                // Building mode - place blocks
                if (!player.selectedItem || (
                    player.selectedItem !== 'block1' && 
                    player.selectedItem !== 'block2' && 
                    player.selectedItem !== 'block3' && 
                    player.selectedItem !== 'block4' &&
                    player.selectedItem !== 'BLOCK5' &&
                    player.selectedItem !== 'BLOCK6' &&
                    player.selectedItem !== 'BLOCK7' &&
                    player.selectedItem !== 'BLOCK8' &&
                    player.selectedItem !== 'BLOCK9' &&
                    player.selectedItem !== 'CREST'
                )) return;
                
                // Check if player has enough blocks
                if (player.inventory[player.selectedItem] <= 0) return;
                
                // Check if position is already occupied by any object
                const isOccupied = 
                    // Check placed blocks
                    placedBlocks.some(block => block.x === worldX && block.y === worldY) ||
                    // Check trees
                    trees.some(tree => 
                        worldX >= tree.x && worldX <= tree.x + TREE_SIZE &&
                        worldY >= tree.y && worldY <= tree.y + TREE_SIZE
                    ) ||
                    // Check rocks
                    rocks.some(rock => 
                        worldX >= rock.x && worldX <= rock.x + ROCK_SIZE &&
                        worldY >= rock.y && worldY <= rock.y + ROCK_SIZE
                    ) ||
                    // Check slimes
                    slimes.some(slime => 
                        worldX >= slime.x && worldX <= slime.x + SLIME_SIZE &&
                        worldY >= slime.y && worldY <= slime.y + SLIME_SIZE
                    ) ||
                    // Check ovcas
                    ovcas.some(ovca => 
                        worldX >= ovca.x && worldX <= ovca.x + OVCA_SIZE &&
                        worldY >= ovca.y && worldY <= ovca.y + OVCA_SIZE
                    ) ||
                    // Check ghosts
                    ghosts.some(ghost => 
                        worldX >= ghost.x && worldX <= ghost.x + GHOST_SIZE &&
                        worldY >= ghost.y && worldY <= ghost.y + GHOST_SIZE
                    ) ||
                    // Check player position
                    (worldX >= player.x && worldX <= player.x + PLAYER_SIZE &&
                     worldY >= player.y && worldY <= player.y + PLAYER_SIZE);
                
                if (!isOccupied) {
                    // Place new block
                    placedBlocks.push({ 
                        x: worldX, 
                        y: worldY,
                        type: player.selectedItem // Store block type
                    });
                    
                    // Initialize storage for BLOCK4
                    if (player.selectedItem === 'block4' && !storageBlocks[blockKey]) {
                        storageBlocks[blockKey] = {
                            items: Array(6).fill(null),
                            counts: Array(6).fill(0)
                        };
                    }
                    
                    player.inventory[player.selectedItem]--;
                    updateInventoryUI();
                    saveGame();
                }
            } else if (player.mineMode) {
                // Mine mode - destroy blocks
                const blockIndex = placedBlocks.findIndex(block => 
                    block.x === worldX && block.y === worldY
                );
                
                if (blockIndex !== -1) {
                    // Destroy block and return it to inventory
                    const block = placedBlocks[blockIndex];
                    
                    // If it's a BLOCK4, drop its contents
                    if (block.type === 'block4' && storageBlocks[blockKey]) {
                        const storage = storageBlocks[blockKey];
                        for (let i = 0; i < storage.items.length; i++) {
                            if (storage.items[i]) {
                                player.inventory[storage.items[i]] = (player.inventory[storage.items[i]] || 0) + storage.counts[i];
                            }
                        }
                        delete storageBlocks[blockKey];
                    }
                    
                    player.inventory[block.type]++;
                    placedBlocks.splice(blockIndex, 1);
                    updateInventoryUI();
                    saveGame();
                }
            } else {
                // Regular click - check if clicking on a special block
                const block = placedBlocks.find(b => b.x === worldX && b.y === worldY);
                if (block) {
                    if (block.type === 'block4') {
                        const blockKey = `${worldX},${worldY}`;
                        const block4Window = document.getElementById('block4-window');
                        
                        // Initialize storage if it doesn't exist
                        if (!storageBlocks[blockKey]) {
                            storageBlocks[blockKey] = {
                                items: Array(6).fill(null),
                                counts: Array(6).fill(0)
                            };
                        }
                        
                        // Update window with this block's storage
                        block4Window.dataset.blockKey = blockKey;
                        updateBlock4Window(blockKey);
                        block4Window.style.display = 'block';
                        
                        // Update transfer buttons based on selected item
                        updateTransferButtons();
                    } else if (block.type === 'BLOCK5') {
                        // Open BLOCK5 crafting window
                        document.getElementById('block5-window').style.display = 'block';
                        updateCraftingButtons();
                    } else if (block.type === 'BLOCK6') {
                        // Open BLOCK6 info window
                        document.getElementById('block6-window').style.display = 'block';
                    } else if (block.type === 'BLOCK8') {
                        // Open BLOCK8 info window
                        document.getElementById('block8-window').style.display = 'block';
                        
                        // Make it morning when clicking BLOCK8
                        isDay = true;
                        dayNightTimer = 0;
                        document.getElementById('day-night').textContent = 'Day';
                    } else if (block.type === 'BLOCK9') {
                        // Open BLOCK9 crafting window
                        document.getElementById('block9-window').style.display = 'block';
                        updateCraftingButtons();
                    }
                } else {
                    // Close windows if clicking elsewhere
                    document.getElementById('block4-window').style.display = 'none';
                    document.getElementById('block5-window').style.display = 'none';
                    document.getElementById('block6-window').style.display = 'none';
                    document.getElementById('block8-window').style.display = 'none';
                    document.getElementById('block9-window').style.display = 'none';
                }
            }
        }

        // Keyboard handlers
        const keys = {};
        function handleKeyDown(e) {
            keys[e.key] = true;
            
            // Update player direction based on last pressed key
            if (e.key === 'ArrowUp' || e.key === 'w') player.direction = { x: 0, y: -1 };
            if (e.key === 'ArrowDown' || e.key === 's') player.direction = { x: 0, y: 1 };
            if (e.key === 'ArrowLeft' || e.key === 'a') player.direction = { x: -1, y: 0 };
            if (e.key === 'ArrowRight' || e.key === 'd') player.direction = { x: 1, y: 0 };
            
            // Toggle build mode with Y key
            if (e.key === 'y' || e.key === 'Y') {
                toggleBuildMode();
            }
            
            // Open crafting with E key
            if (e.key === 'e' || e.key === 'E') {
                const craftingWindow = document.getElementById('crafting-window');
                craftingWindow.style.display = craftingWindow.style.display === 'block' ? 'none' : 'block';
                updateCraftingButtons();
            }
            
            // Toggle mine mode with T key
            if (e.key === 't' || e.key === 'T') {
                toggleMineMode();
            }
            
            // Number keys for inventory selection
            if (e.key === '1' && player.inventory.wood > 0) {
                player.selectedItem = 'wood';
                updateInventorySelection();
            }
            if (e.key === '2' && player.inventory.stone > 0) {
                player.selectedItem = 'stone';
                updateInventorySelection();
            }
            if (e.key === '3' && player.inventory.block1 > 0) {
                player.selectedItem = 'block1';
                updateInventorySelection();
            }
            if (e.key === '4' && player.inventory.block2 > 0) {
                player.selectedItem = 'block2';
                updateInventorySelection();
            }
            if (e.key === '5' && player.inventory.block3 > 0) {
                player.selectedItem = 'block3';
                updateInventorySelection();
            }
            if (e.key === '6' && player.inventory.block4 > 0) {
                player.selectedItem = 'block4';
                updateInventorySelection();
            }
            if (e.key === '7' && player.inventory.PAlKA > 0) {
                player.selectedItem = 'PAlKA';
                updateInventorySelection();
            }
            if (e.key === '8' && player.inventory.BLOCK5 > 0) {
                player.selectedItem = 'BLOCK5';
                updateInventorySelection();
            }
            if (e.key === '9' && player.inventory.UGL > 0) {
                player.selectedItem = 'UGL';
                updateInventorySelection();
            }
            if (e.key === '0' && player.inventory.BLOCK6 > 0) {
                player.selectedItem = 'BLOCK6';
                updateInventorySelection();
            }
            
            // Space for attack
            if (e.key === ' ') {
                attackPressed = true;
                document.getElementById('attack-btn').classList.add('active');
                
                // If HEAD is selected and attack is pressed, activate ghost mode
                if (player.selectedItem === 'HEAD') {
                    activateGhostMode();
                }
            }
        }

        // Update inventory selection UI
        function updateInventorySelection() {
            const slots = document.querySelectorAll('.inventory-slot');
            slots.forEach(slot => {
                slot.classList.remove('selected');
                if (slot.dataset.item === player.selectedItem) {
                    slot.classList.add('selected');
                }
            });
            
            // Update transfer buttons if BLOCK4 window is open
            if (document.getElementById('block4-window').style.display === 'block') {
                updateTransferButtons();
            }
        }

        function handleKeyUp(e) {
            keys[e.key] = false;
            
            // Space for attack
            if (e.key === ' ') {
                attackPressed = false;
                document.getElementById('attack-btn').classList.remove('active');
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update() {
            // Update player position based on keyboard input
            let moveX = 0, moveY = 0;
            
            if (keys['ArrowUp'] || keys['w']) moveY = -player.speed;
            if (keys['ArrowDown'] || keys['s']) moveY = player.speed;
            if (keys['ArrowLeft'] || keys['a']) moveX = -player.speed;
            if (keys['ArrowRight'] || keys['d']) moveX = player.speed;
            
            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071; // 1/sqrt(2)
                moveY *= 0.7071;
            }
            
            // Update player position with collision detection
            const newX = player.x + moveX;
            const newY = player.y + moveY;
            
            // Check world boundaries
            if (newX >= 0 && newX <= WORLD_SIZE - PLAYER_SIZE) {
                player.x = newX;
            }
            if (newY >= 0 && newY <= WORLD_SIZE - PLAYER_SIZE) {
                player.y = newY;
            }
            
            // Check collision with placed blocks (only for non-player-pass blocks and when not in ghost mode)
            if (!player.ghostMode) {
                const playerRect = {
                    x: player.x,
                    y: player.y,
                    width: PLAYER_SIZE,
                    height: PLAYER_SIZE
                };
                
                for (const block of placedBlocks) {
                    // Skip collision check for player-pass blocks (type block3 and BLOCK6)
                    if (block.type === 'block3' || block.type === 'BLOCK6') continue;
                    
                    const blockRect = {
                        x: block.x,
                        y: block.y,
                        width: BLOCK_SIZE,
                        height: BLOCK_SIZE
                    };
                    
                    if (checkCollision(playerRect, blockRect)) {
                        // Move player back
                        player.x -= moveX;
                        player.y -= moveY;
                        break;
                    }
                }
            }
            
            // Update camera to follow player
            camera.x = player.x + PLAYER_SIZE/2 - canvas.width/2;
            camera.y = player.y + PLAYER_SIZE/2 - canvas.height/2;
            
            // Keep camera within world bounds
            camera.x = Math.max(0, Math.min(camera.x, WORLD_SIZE - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_SIZE - canvas.height));
            
            // Update ghost mode timer
            if (player.ghostMode) {
                player.ghostModeTimer -= 1/60; // Assuming 60 FPS
                if (player.ghostModeTimer <= 0) {
                    player.ghostMode = false;
                }
            }
            
            // Update day/night cycle with smooth transitions
            dayNightTimer += 1/60; // Assuming 60 FPS
            
            // Calculate day/night progress (0 to 1)
            let dayNightProgress;
            if (isDay) {
                dayNightProgress = dayNightTimer / DAY_NIGHT_CYCLE;
                
                // Transition to night when day cycle completes
                if (dayNightTimer >= DAY_NIGHT_CYCLE) {
                    isDay = false;
                    dayNightTimer = 0;
                    document.getElementById('day-night').textContent = 'Night';
                }
            } else {
                dayNightProgress = dayNightTimer / NIGHT_DURATION;
                
                // Transition to day when night cycle completes
                if (dayNightTimer >= NIGHT_DURATION) {
                    isDay = true;
                    dayNightTimer = 0;
                    document.getElementById('day-night').textContent = 'Day';
                }
            }
            
            // Spawn slimes at night (with reduced rate and max count)
            if (!isDay && slimes.length < SLIME_MAX_COUNT) {
                slimeSpawnTimer += 1/60;
                if (slimeSpawnTimer >= SLIME_SPAWN_RATE) {
                    slimeSpawnTimer = 0;
                    
                    // Spawn slime at random position near player but not too close
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 300 + Math.random() * 200;
                    const x = player.x + Math.cos(angle) * distance;
                    const y = player.y + Math.sin(angle) * distance;
                    
                    // Make sure slime is within world bounds
                    if (x >= 0 && x <= WORLD_SIZE - SLIME_SIZE && y >= 0 && y <= WORLD_SIZE - SLIME_SIZE) {
                        slimes.push({
                            x,
                            y,
                            health: 10,
                            speed: 1 + Math.random() * 0.5,
                            attackCooldown: 0,
                            attackRate: 1,
                            damage: 5
                        });
                    }
                }
            } else if (isDay) {
                // Clear slimes during day
                if (slimes.length > 0) {
                    slimes = [];
                }
            }
            
            // Spawn OVCA (sheep) - adjusted spawn rate based on current count
            ovcaSpawnTimer += 1/60;
            const ovcaSpawnRate = ovcas.length <= 5 ? OVCA_SPAWN_RATE_FAST : OVCA_SPAWN_RATE_SLOW;
            
            if (ovcaSpawnTimer >= ovcaSpawnRate) {
                ovcaSpawnTimer = 0;
                
                // Spawn ovca at random position
                const x = Math.random() * (WORLD_SIZE - OVCA_SIZE);
                const y = Math.random() * (WORLD_SIZE - OVCA_SIZE);
                
                ovcas.push({
                    x,
                    y,
                    health: 15,
                    speed: 0.5 + Math.random() * 0.5,
                    direction: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 },
                    directionChangeTimer: 0,
                    directionChangeInterval: 2 + Math.random() * 3
                });
            }
            
            // Spawn GHOSTs at night if player level > 5
            if (!isDay && player.level > 5) {
                ghostSpawnTimer += 1/60;
                
                // Calculate max ghosts based on player level
                const maxGhosts = Math.min(GHOST_BASE_MAX + Math.floor(player.level / 2), GHOST_MAX_LEVEL);
                
                if (ghostSpawnTimer >= GHOST_SPAWN_RATE && ghosts.length < maxGhosts) {
                    ghostSpawnTimer = 0;
                    
                    // Spawn ghost at random position near player but not too close
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 300 + Math.random() * 200;
                    const x = player.x + Math.cos(angle) * distance;
                    const y = player.y + Math.sin(angle) * distance;
                    
                    // Make sure ghost is within world bounds
                    if (x >= 0 && x <= WORLD_SIZE - GHOST_SIZE && y >= 0 && y <= WORLD_SIZE - GHOST_SIZE) {
                        ghosts.push({
                            x,
                            y,
                            health: 20,
                            speed: 1.5 + Math.random() * 0.5,
                            attackCooldown: 0,
                            attackRate: 1.5,
                            damage: 30
                        });
                    }
                }
            } else if (isDay) {
                // Clear ghosts during day
                if (ghosts.length > 0) {
                    ghosts = [];
                }
            }
            
            // Update slimes
            for (let i = slimes.length - 1; i >= 0; i--) {
                const slime = slimes[i];
                
                // Move slime toward player, avoiding blocks
                const dx = player.x + PLAYER_SIZE/2 - (slime.x + SLIME_SIZE/2);
                const dy = player.y + PLAYER_SIZE/2 - (slime.y + SLIME_SIZE/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    let moveX = (dx / distance) * slime.speed;
                    let moveY = (dy / distance) * slime.speed;
                    
                    // Check for collisions with blocks (including player-pass blocks)
                    const slimeRect = {
                        x: slime.x + moveX,
                        y: slime.y + moveY,
                        width: SLIME_SIZE,
                        height: SLIME_SIZE
                    };
                    
                    let canMove = true;
                    for (const block of placedBlocks) {
                        const blockRect = {
                            x: block.x,
                            y: block.y,
                            width: BLOCK_SIZE,
                            height: BLOCK_SIZE
                        };
                        
                        if (checkCollision(slimeRect, blockRect)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    if (canMove) {
                        slime.x += moveX;
                        slime.y += moveY;
                    } else {
                        // Try to move in just X or Y direction
                        const tryX = { ...slimeRect, x: slime.x + moveX, y: slime.y };
                        const tryY = { ...slimeRect, x: slime.x, y: slime.y + moveY };
                        
                        let canMoveX = true;
                        let canMoveY = true;
                        
                        for (const block of placedBlocks) {
                            const blockRect = {
                                x: block.x,
                                y: block.y,
                                width: BLOCK_SIZE,
                                height: BLOCK_SIZE
                            };
                            
                            if (checkCollision(tryX, blockRect)) canMoveX = false;
                            if (checkCollision(tryY, blockRect)) canMoveY = false;
                        }
                        
                        if (canMoveX) slime.x += moveX;
                        if (canMoveY) slime.y += moveY;
                    }
                }
                
                // Attack player if close enough
                if (distance < 40 && slime.attackCooldown <= 0) {
                    player.health -= slime.damage;
                    slime.attackCooldown = slime.attackRate;
                    
                    // Update health bar
                    document.getElementById('health-fill').style.width = `${(player.health / player.maxHealth) * 100}%`;
                    
                    // Check if player died
                    if (player.health <= 0) {
                        player.health = player.maxHealth;
                        // Respawn player at center
                        player.x = WORLD_SIZE / 2;
                        player.y = WORLD_SIZE / 2;
                        document.getElementById('health-fill').style.width = '100%';
                        saveGame();
                    }
                }
                
                // Update attack cooldown
                if (slime.attackCooldown > 0) {
                    slime.attackCooldown -= 1/60;
                }
                
                // Remove dead slimes
                if (slime.health <= 0) {
                    slimes.splice(i, 1);
                    // Add experience
                    player.exp += 20;
                    // Check level up
                    if (player.exp >= player.expToNextLevel) {
                        player.level++;
                        player.exp -= player.expToNextLevel;
                        player.expToNextLevel = Math.floor(player.expToNextLevel * 1.5);
                        player.maxHealth += 20;
                        player.health = player.maxHealth;
                        player.attackDamage += 2;
                        document.getElementById('level').textContent = `Level: ${player.level}`;
                        document.getElementById('health-fill').style.width = '100%';
                    }
                    // Update exp bar
                    document.getElementById('exp-fill').style.width = `${(player.exp / player.expToNextLevel) * 100}%`;
                    saveGame();
                }
            }
            
            // Update OVCAs (sheep)
            for (let i = ovcas.length - 1; i >= 0; i--) {
                const ovca = ovcas[i];
                
                // Change direction periodically
                ovca.directionChangeTimer += 1/60;
                if (ovca.directionChangeTimer >= ovca.directionChangeInterval) {
                    ovca.directionChangeTimer = 0;
                    ovca.directionChangeInterval = 2 + Math.random() * 3;
                    ovca.direction = { 
                        x: Math.random() * 2 - 1, 
                        y: Math.random() * 2 - 1 
                    };
                    
                    // Normalize direction
                    const length = Math.sqrt(ovca.direction.x * ovca.direction.x + ovca.direction.y * ovca.direction.y);
                    if (length > 0) {
                        ovca.direction.x /= length;
                        ovca.direction.y /= length;
                    }
                }
                
                // Move ovca
                let moveX = ovca.direction.x * ovca.speed;
                let moveY = ovca.direction.y * ovca.speed;
                
                // Check for collisions with blocks (including player-pass blocks)
                const ovcaRect = {
                    x: ovca.x + moveX,
                    y: ovca.y + moveY,
                    width: OVCA_SIZE,
                    height: OVCA_SIZE
                };
                
                let canMove = true;
                for (const block of placedBlocks) {
                    const blockRect = {
                        x: block.x,
                        y: block.y,
                        width: BLOCK_SIZE,
                        height: BLOCK_SIZE
                    };
                    
                    if (checkCollision(ovcaRect, blockRect)) {
                        canMove = false;
                        break;
                    }
                }
                
                // Also check collision with trees and rocks
                for (const tree of trees) {
                    const treeRect = {
                        x: tree.x,
                        y: tree.y,
                        width: TREE_SIZE,
                        height: TREE_SIZE
                    };
                    
                    if (checkCollision(ovcaRect, treeRect)) {
                        canMove = false;
                        break;
                    }
                }
                
                for (const rock of rocks) {
                    const rockRect = {
                        x: rock.x,
                        y: rock.y,
                        width: ROCK_SIZE,
                        height: ROCK_SIZE
                    };
                    
                    if (checkCollision(ovcaRect, rockRect)) {
                        canMove = false;
                        break;
                    }
                }
                
                if (canMove) {
                    ovca.x += moveX;
                    ovca.y += moveY;
                } else {
                    // Change direction if blocked
                    ovca.directionChangeTimer = ovca.directionChangeInterval;
                }
                
                // Keep ovca within world bounds
                ovca.x = Math.max(0, Math.min(ovca.x, WORLD_SIZE - OVCA_SIZE));
                ovca.y = Math.max(0, Math.min(ovca.y, WORLD_SIZE - OVCA_SIZE));
                
                // Remove dead ovcas
                if (ovca.health <= 0) {
                    ovcas.splice(i, 1);
                    // Drop BLOCK7 when killed
                    player.inventory.BLOCK7 += 1;
                    updateInventoryUI();
                    saveGame();
                }
            }
            
            // Update GHOSTs
            for (let i = ghosts.length - 1; i >= 0; i--) {
                const ghost = ghosts[i];
                
                // Move ghost toward player, passing through all blocks except CREST
                const dx = player.x + PLAYER_SIZE/2 - (ghost.x + GHOST_SIZE/2);
                const dy = player.y + PLAYER_SIZE/2 - (ghost.y + GHOST_SIZE/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    let moveX = (dx / distance) * ghost.speed;
                    let moveY = (dy / distance) * ghost.speed;
                    
                    // Check for collisions with CREST blocks
                    const ghostRect = {
                        x: ghost.x + moveX,
                        y: ghost.y + moveY,
                        width: GHOST_SIZE,
                        height: GHOST_SIZE
                    };
                    
                    let canMove = true;
                    for (const block of placedBlocks) {
                        if (block.type === 'CREST') {
                            const blockRect = {
                                x: block.x,
                                y: block.y,
                                width: BLOCK_SIZE,
                                height: BLOCK_SIZE
                            };
                            
                            if (checkCollision(ghostRect, blockRect)) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                    
                    if (canMove) {
                        ghost.x += moveX;
                        ghost.y += moveY;
                    } else {
                        // Try to move in just X or Y direction
                        const tryX = { ...ghostRect, x: ghost.x + moveX, y: ghost.y };
                        const tryY = { ...ghostRect, x: ghost.x, y: ghost.y + moveY };
                        
                        let canMoveX = true;
                        let canMoveY = true;
                        
                        for (const block of placedBlocks) {
                            if (block.type === 'CREST') {
                                const blockRect = {
                                    x: block.x,
                                    y: block.y,
                                    width: BLOCK_SIZE,
                                    height: BLOCK_SIZE
                                };
                                
                                if (checkCollision(tryX, blockRect)) canMoveX = false;
                                if (checkCollision(tryY, blockRect)) canMoveY = false;
                            }
                        }
                        
                        if (canMoveX) ghost.x += moveX;
                        if (canMoveY) ghost.y += moveY;
                    }
                }
                
                // Attack player if close enough
                if (distance < 40 && ghost.attackCooldown <= 0) {
                    player.health -= ghost.damage;
                    ghost.attackCooldown = ghost.attackRate;
                    
                    // Update health bar
                    document.getElementById('health-fill').style.width = `${(player.health / player.maxHealth) * 100}%`;
                    
                    // Check if player died
                    if (player.health <= 0) {
                        player.health = player.maxHealth;
                        // Respawn player at center
                        player.x = WORLD_SIZE / 2;
                        player.y = WORLD_SIZE / 2;
                        document.getElementById('health-fill').style.width = '100%';
                        saveGame();
                    }
                }
                
                // Update attack cooldown
                if (ghost.attackCooldown > 0) {
                    ghost.attackCooldown -= 1/60;
                }
                
                // Remove dead ghosts
                if (ghost.health <= 0) {
                    ghosts.splice(i, 1);
                    // Add experience
                    player.exp += 50;
                    
                    // 20% chance to drop HEAD.png
                    if (Math.random() < HEAD_DROP_CHANCE) {
                        player.inventory.HEAD += 1;
                        updateInventoryUI();
                    }
                    
                    // Check level up
                    if (player.exp >= player.expToNextLevel) {
                        player.level++;
                        player.exp -= player.expToNextLevel;
                        player.expToNextLevel = Math.floor(player.expToNextLevel * 1.5);
                        player.maxHealth += 20;
                        player.health = player.maxHealth;
                        player.attackDamage += 2;
                        document.getElementById('level').textContent = `Level: ${player.level}`;
                        document.getElementById('health-fill').style.width = '100%';
                    }
                    // Update exp bar
                    document.getElementById('exp-fill').style.width = `${(player.exp / player.expToNextLevel) * 100}%`;
                    saveGame();
                }
            }
            
            // Player attack (also used for harvesting resources)
            if (player.attackCooldown > 0) {
                player.attackCooldown -= 1/60;
            } else if (attackPressed || keys[' ']) {
                player.attackCooldown = 0.5; // Attack cooldown in seconds
                
                // Check for slimes in attack range
                for (const slime of slimes) {
                    const dx = slime.x + SLIME_SIZE/2 - (player.x + PLAYER_SIZE/2);
                    const dy = slime.y + SLIME_SIZE/2 - (player.y + PLAYER_SIZE/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.attackRange) {
                        slime.health -= player.attackDamage;
                    }
                }
                
                // Check for ovcas in attack range
                for (const ovca of ovcas) {
                    const dx = ovca.x + OVCA_SIZE/2 - (player.x + PLAYER_SIZE/2);
                    const dy = ovca.y + OVCA_SIZE/2 - (player.y + PLAYER_SIZE/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.attackRange) {
                        ovca.health -= player.attackDamage;
                    }
                }
                
                // Check for ghosts in attack range
                for (const ghost of ghosts) {
                    const dx = ghost.x + GHOST_SIZE/2 - (player.x + PLAYER_SIZE/2);
                    const dy = ghost.y + GHOST_SIZE/2 - (player.y + PLAYER_SIZE/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.attackRange) {
                        ghost.health -= player.attackDamage;
                    }
                }
                
                // Check for trees in harvest range
                for (let i = trees.length - 1; i >= 0; i--) {
                    const tree = trees[i];
                    const dx = tree.x + TREE_SIZE/2 - (player.x + PLAYER_SIZE/2);
                    const dy = tree.y + TREE_SIZE/2 - (player.y + PLAYER_SIZE/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < HARVEST_RANGE) {
                        tree.health--;
                        
                        if (tree.health <= 0) {
                            // Tree is destroyed, remove it and add wood to inventory
                            trees.splice(i, 1);
                            player.inventory.wood += 1; // Changed from 4 to 1 as requested
                            updateInventoryUI();
                            saveGame();
                        }
                    }
                }
                
                // Check for rocks in harvest range
                for (let i = rocks.length - 1; i >= 0; i--) {
                    const rock = rocks[i];
                    const dx = rock.x + ROCK_SIZE/2 - (player.x + PLAYER_SIZE/2);
                    const dy = rock.y + ROCK_SIZE/2 - (player.y + PLAYER_SIZE/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < HARVEST_RANGE) {
                        rock.health--;
                        
                        if (rock.health <= 0) {
                            // Rock is destroyed, remove it and add stone to inventory
                            rocks.splice(i, 1);
                            player.inventory.stone += 2;
                            updateInventoryUI();
                            saveGame();
                        }
                    }
                }
            }
        }

        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Render game
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate visible area
            const startX = Math.floor(camera.x / TILE_SIZE);
            const startY = Math.floor(camera.y / TILE_SIZE);
            const endX = Math.ceil((camera.x + canvas.width) / TILE_SIZE);
            const endY = Math.ceil((camera.y + canvas.height) / TILE_SIZE);
            
            // Draw grass tiles
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const tileX = x * TILE_SIZE - camera.x;
                    const tileY = y * TILE_SIZE - camera.y;
                    
                    ctx.drawImage(textures.trava, tileX, tileY, TILE_SIZE, TILE_SIZE);
                }
            }
            
            // Draw placed blocks
            for (const block of placedBlocks) {
                const blockX = block.x - camera.x;
                const blockY = block.y - camera.y;
                
                // Only draw if visible
                if (blockX + BLOCK_SIZE > 0 && blockX < canvas.width &&
                    blockY + BLOCK_SIZE > 0 && blockY < canvas.height) {
                    let texture;
                    if (block.type === 'block2') {
                        texture = textures.block2;
                    } else if (block.type === 'block3') {
                        texture = textures.block3;
                    } else if (block.type === 'block4') {
                        texture = textures.block4;
                    } else if (block.type === 'PAlKA') {
                        texture = textures.PAlKA;
                    } else if (block.type === 'BLOCK5') {
                        texture = textures.BLOCK5;
                    } else if (block.type === 'BLOCK6') {
                        texture = textures.BLOCK6;
                    } else if (block.type === 'BLOCK7') {
                        texture = textures.BLOCK7;
                    } else if (block.type === 'BLOCK8') {
                        texture = textures.BLOCK8;
                    } else if (block.type === 'BLOCK9') {
                        texture = textures.BLOCK9;
                    } else if (block.type === 'UGL') {
                        texture = textures.UGL;
                    } else if (block.type === 'CREST') {
                        texture = textures.CREST;
                    } else {
                        texture = textures.block1;
                    }
                    ctx.drawImage(texture, blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            
            // Draw rocks
            for (const rock of rocks) {
                const rockX = rock.x - camera.x;
                const rockY = rock.y - camera.y;
                
                // Only draw if visible
                if (rockX + ROCK_SIZE > 0 && rockX < canvas.width &&
                    rockY + ROCK_SIZE > 0 && rockY < canvas.height) {
                    ctx.drawImage(textures.rock, rockX, rockY, ROCK_SIZE, ROCK_SIZE);
                    
                    // Draw health bar if damaged
                    if (rock.health < 5) {
                        const healthPercentage = rock.health / 5;
                        ctx.fillStyle = 'red';
                        ctx.fillRect(rockX, rockY - 10, ROCK_SIZE, 5);
                        ctx.fillStyle = 'green';
                        ctx.fillRect(rockX, rockY - 10, ROCK_SIZE * healthPercentage, 5);
                    }
                }
            }
            
            // Draw trees
            for (const tree of trees) {
                const treeX = tree.x - camera.x;
                const treeY = tree.y - camera.y;
                
                // Only draw if visible
                if (treeX + TREE_SIZE > 0 && treeX < canvas.width &&
                    treeY + TREE_SIZE > 0 && treeY < canvas.height) {
                    ctx.drawImage(textures.tree, treeX, treeY, TREE_SIZE, TREE_SIZE);
                    
                    // Draw health bar if damaged
                    if (tree.health < 3) {
                        const healthPercentage = tree.health / 3;
                        ctx.fillStyle = 'red';
                        ctx.fillRect(treeX, treeY - 10, TREE_SIZE, 5);
                        ctx.fillStyle = 'green';
                        ctx.fillRect(treeX, treeY - 10, TREE_SIZE * healthPercentage, 5);
                    }
                }
            }
            
            // Draw slimes
            for (const slime of slimes) {
                const slimeX = slime.x - camera.x;
                const slimeY = slime.y - camera.y;
                
                // Only draw if visible
                if (slimeX + SLIME_SIZE > 0 && slimeX < canvas.width &&
                    slimeY + SLIME_SIZE > 0 && slimeY < canvas.height) {
                    ctx.drawImage(textures.slime, slimeX, slimeY, SLIME_SIZE, SLIME_SIZE);
                    
                    // Draw health bar
                    const healthPercentage = slime.health / 10;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(slimeX, slimeY - 10, SLIME_SIZE, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(slimeX, slimeY - 10, SLIME_SIZE * healthPercentage, 5);
                }
            }
            
            // Draw OVCAs (sheep)
            for (const ovca of ovcas) {
                const ovcaX = ovca.x - camera.x;
                const ovcaY = ovca.y - camera.y;
                
                // Only draw if visible
                if (ovcaX + OVCA_SIZE > 0 && ovcaX < canvas.width &&
                    ovcaY + OVCA_SIZE > 0 && ovcaY < canvas.height) {
                    ctx.drawImage(textures.ovca, ovcaX, ovcaY, OVCA_SIZE, OVCA_SIZE);
                    
                    // Draw health bar if damaged
                    if (ovca.health < 15) {
                        const healthPercentage = ovca.health / 15;
                        ctx.fillStyle = 'red';
                        ctx.fillRect(ovcaX, ovcaY - 10, OVCA_SIZE, 5);
                        ctx.fillStyle = 'green';
                        ctx.fillRect(ovcaX, ovcaY - 10, OVCA_SIZE * healthPercentage, 5);
                    }
                }
            }
            
            // Draw GHOSTs
            for (const ghost of ghosts) {
                const ghostX = ghost.x - camera.x;
                const ghostY = ghost.y - camera.y;
                
                // Only draw if visible
                if (ghostX + GHOST_SIZE > 0 && ghostX < canvas.width &&
                    ghostY + GHOST_SIZE > 0 && ghostY < canvas.height) {
                    ctx.globalAlpha = 0.8; // Make ghosts semi-transparent
                    ctx.drawImage(textures.ghost, ghostX, ghostY, GHOST_SIZE, GHOST_SIZE);
                    ctx.globalAlpha = 1.0;
                    
                    // Draw health bar
                    const healthPercentage = ghost.health / 20;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(ghostX, ghostY - 10, GHOST_SIZE, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(ghostX, ghostY - 10, GHOST_SIZE * healthPercentage, 5);
                }
            }
            
            // Draw player
            const playerX = player.x - camera.x;
            const playerY = player.y - camera.y;
            
            // Make player semi-transparent in ghost mode
            if (player.ghostMode) {
                ctx.globalAlpha = 0.5;
            }
            
            ctx.drawImage(textures.player, playerX, playerY, PLAYER_SIZE, PLAYER_SIZE);
            ctx.globalAlpha = 1.0;
            
            // Draw attack effect if attacking
            if (player.attackCooldown > 0.4) { // First 0.1 seconds of attack
                ctx.beginPath();
                ctx.arc(
                    playerX + PLAYER_SIZE/2 + player.direction.x * player.attackRange/2,
                    playerY + PLAYER_SIZE/2 + player.direction.y * player.attackRange/2,
                    player.attackRange/2,
                    0,
                    Math.PI * 2
                );
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Draw build preview if in build mode with block selected
            if (player.buildMode && (
                player.selectedItem === 'block1' || 
                player.selectedItem === 'block2' || 
                player.selectedItem === 'block3' || 
                player.selectedItem === 'block4' ||
                player.selectedItem === 'PAlKA' ||
                player.selectedItem === 'BLOCK5' ||
                player.selectedItem === 'BLOCK6' ||
                player.selectedItem === 'BLOCK7' ||
                player.selectedItem === 'BLOCK8' ||
                player.selectedItem === 'BLOCK9' ||
                player.selectedItem === 'UGL' ||
                player.selectedItem === 'CREST'
            )) {
                // Get mouse position
                const mouseX = player.direction.x * player.attackRange + player.x + PLAYER_SIZE/2;
                const mouseY = player.direction.y * player.attackRange + player.y + PLAYER_SIZE/2;
                
                // Snap to grid
                const blockX = Math.floor(mouseX / BLOCK_SIZE) * BLOCK_SIZE;
                const blockY = Math.floor(mouseY / BLOCK_SIZE) * BLOCK_SIZE;
                
                // Check if position is occupied
                const isOccupied = 
                    placedBlocks.some(block => block.x === blockX && block.y === blockY) ||
                    trees.some(tree => 
                        blockX >= tree.x && blockX <= tree.x + TREE_SIZE &&
                        blockY >= tree.y && blockY <= tree.y + TREE_SIZE
                    ) ||
                    rocks.some(rock => 
                        blockX >= rock.x && blockX <= rock.x + ROCK_SIZE &&
                        blockY >= rock.y && blockY <= rock.y + ROCK_SIZE
                    ) ||
                    slimes.some(slime => 
                        blockX >= slime.x && blockX <= slime.x + SLIME_SIZE &&
                        blockY >= slime.y && blockY <= slime.y + SLIME_SIZE
                    ) ||
                    ovcas.some(ovca => 
                        blockX >= ovca.x && blockX <= ovca.x + OVCA_SIZE &&
                        blockY >= ovca.y && blockY <= ovca.y + OVCA_SIZE
                    ) ||
                    ghosts.some(ghost => 
                        blockX >= ghost.x && blockX <= ghost.x + GHOST_SIZE &&
                        blockY >= ghost.y && blockY <= ghost.y + GHOST_SIZE
                    ) ||
                    (blockX >= player.x && blockX <= player.x + PLAYER_SIZE &&
                     blockY >= player.y && blockY <= player.y + PLAYER_SIZE);
                
                // Draw preview
                ctx.globalAlpha = 0.7;
                let texture;
                if (player.selectedItem === 'block2') {
                    texture = textures.block2;
                } else if (player.selectedItem === 'block3') {
                    texture = textures.block3;
                } else if (player.selectedItem === 'block4') {
                    texture = textures.block4;
                } else if (player.selectedItem === 'PAlKA') {
                    texture = textures.PAlKA;
                } else if (player.selectedItem === 'BLOCK5') {
                    texture = textures.BLOCK5;
                } else if (player.selectedItem === 'BLOCK6') {
                    texture = textures.BLOCK6;
                } else if (player.selectedItem === 'BLOCK7') {
                    texture = textures.BLOCK7;
                } else if (player.selectedItem === 'BLOCK8') {
                    texture = textures.BLOCK8;
                } else if (player.selectedItem === 'BLOCK9') {
                    texture = textures.BLOCK9;
                } else if (player.selectedItem === 'UGL') {
                    texture = textures.UGL;
                } else if (player.selectedItem === 'CREST') {
                    texture = textures.CREST;
                } else {
                    texture = textures.block1;
                }
                ctx.fillStyle = isOccupied ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.5)';
                ctx.fillRect(blockX - camera.x, blockY - camera.y, BLOCK_SIZE, BLOCK_SIZE);
                ctx.drawImage(
                    texture, 
                    blockX - camera.x, 
                    blockY - camera.y, 
                    BLOCK_SIZE, 
                    BLOCK_SIZE
                );
                ctx.globalAlpha = 1.0;
            }
            
            // Draw mine preview if in mine mode
            if (player.mineMode) {
                // Get mouse position
                const mouseX = player.direction.x * player.attackRange + player.x + PLAYER_SIZE/2;
                const mouseY = player.direction.y * player.attackRange + player.y + PLAYER_SIZE/2;
                
                // Snap to grid
                const blockX = Math.floor(mouseX / BLOCK_SIZE) * BLOCK_SIZE;
                const blockY = Math.floor(mouseY / BLOCK_SIZE) * BLOCK_SIZE;
                
                // Check if there's a block to mine
                const hasBlock = placedBlocks.some(block => block.x === blockX && block.y === blockY);
                
                // Draw preview
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = hasBlock ? 'rgba(255, 165, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(blockX - camera.x, blockY - camera.y, BLOCK_SIZE, BLOCK_SIZE);
                ctx.globalAlpha = 1.0;
            }
            
            // Apply day/night filter with smooth transitions
            if (!isDay) {
                // Calculate darkness intensity based on dayNightTimer
                let darknessIntensity;
                if (dayNightTimer < 60) { // First minute of night - getting darker
                    darknessIntensity = 0.7 * (dayNightTimer / 60);
                } else if (dayNightTimer > NIGHT_DURATION - 60) { // Last minute of night - getting lighter
                    darknessIntensity = 0.7 * ((NIGHT_DURATION - dayNightTimer) / 60);
                } else {
                    darknessIntensity = 0.7; // Full darkness
                }
                
                ctx.fillStyle = `rgba(0, 0, 30, ${darknessIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw light from BLOCK6 blocks during night
                for (const block of placedBlocks) {
                    if (block.type === 'BLOCK6') {
                        const blockX = block.x - camera.x + BLOCK_SIZE/2;
                        const blockY = block.y - camera.y + BLOCK_SIZE/2;
                        
                        // Create radial gradient for light effect
                        const gradient = ctx.createRadialGradient(
                            blockX, blockY, 10,
                            blockX, blockY, LIGHT_RADIUS
                        );
                        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(blockX, blockY, LIGHT_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else {
                // Daytime transitions
                if (dayNightTimer < 60) { // First minute of day - getting lighter
                    const lightness = 0.7 * (1 - (dayNightTimer / 60));
                    ctx.fillStyle = `rgba(0, 0, 30, ${lightness})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else if (dayNightTimer > DAY_NIGHT_CYCLE - 60) { // Last minute of day - getting darker
                    const darkness = 0.7 * ((dayNightTimer - (DAY_NIGHT_CYCLE - 60)) / 60);
                    ctx.fillStyle = `rgba(0, 0, 30, ${darkness})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        // Start the game
        window.onload = init;

        // Save game when page is closed
        window.addEventListener('beforeunload', saveGame);
    </script>
</body>
</html>
